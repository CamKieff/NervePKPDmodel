# Pharmacokinetic-Pharmacodynamic Neuromuscular Junction Model Code

This repository is code for part of my dissertation project.  Electric field stimulation (EFS) is applied to tracheal ring segments. Force of contraction is measured experimentally and then computationally modeled as a series of pharmacokinetic compartments.

The raw data are maintained locally and contained in two folders corresponding to the upper trachea and the lower trachea. Both folders are subdivided into control (con) and capsaicin (cap) folders.  Data are CSV files formatted with "Time" in the right hand column followed by increasing frequency response data from "0.1Hz" to "30Hz". The data are trachea responses measured in mg of tension. Time is in seconds with measurements every 0.02 seconds.  Total record time is 10 seconds.  All data have been formatted so that EFS begins at Time = 0. Data in the capsaicin folder has been pre-treated for 2 hours with 100 uM capsaicin and 10 uM indomethacin followed by a 30-minute washout period.  Not all data are created equal: in the lower trachea only files 1, 2, 5, and 7 had characteristic responses and were used in analysis.

The file model_2drugs.R is a working file that contains instances of running the model functions described below. The model workflow begins with loading required packages and files, then the initial parameters are defined, the model is compiled, and the data file to be tested is imported.  The model is run to find best-fit parameters and the results can be exported or graphed.

####normalizedDF.R

The function `loadNormalizedDF` imports a selected data frame and normalizes the mg of tension response to a maximum. Parameters passed to the function include the section of trachea ("lower" or "upper") where the data was collected, data to be normalized ("con" or "cap" data), data to be used in the denominator to normalize (again, "con" or "cap" data), and the index for the file data file in its respective folder (integer that indicates the position of the file in the folder). In the lower trachea, capsaicin data is used to normalize both capsaicin and control data.  In the upper trachea however, control responses may have greater maxima than capsaicin responses and it may be necessary to normalize control responses to themselves.

####defineModel.R

The `defineModel` function from defineModel.R creates and compiles the model to be tested using the `RxODE` package.  The ACh component of the model can be "simple" with first-order one-compartment model kinetics or "complex" with saturable kinetics for absorption and elimination. The unknown relaxant component can be non-existent ("none") or present as a one-compartment first-order neurotransmitter ("simple"). If there is no unknown relaxant the effect model will default to a single neurotransmitter effect model.  If there is a defined unknown relaxant model there are two options for the way these two neurotransmitter effects are summed together. In the case of the "twoNT_1" option the relaxant effect is subtracted from the ACh effect and the product of the two effects is added back (*this has a name*). The "twoNT_2" option diminishes the ACh maximum effect proportionally to the unknown effect.

####runModelFunctions.R

The major workhorses that bring the magic of the model together are `run_mod1` and `final_drug_params` functions. After importing the data, defining a model, and choosing a set of initial parameters, `run_mod1` runs the model using the `RxODE` package.

`run_mod1` first maps the "init_params" to the parameters defined in the model. Next it builds the event table.  The event table is a list of doses of drug to be administered based on the EFS frequency. The event table contains some "init_params" for the doses of neurotransmitter being administered. Finally it solves the model and returns a data frame of the compartment concentrations and predicted effects at each time point (0.02 s).

One run of `final_drug_params` finds a set of best-fit parameters for the chosen model.  The function runs `run_mod1` repeatedly, each time choosing new parameters and trying to minimize the sum of squares.  The parameters to be optimized are defined in the "bestfit" vector. Any combination of parameters from the "init_params" list can be fit by the function as long as they are in the defined model.  The results of `final_drug_params` can be saved as a data frame of either all the tested parameters, or a data frame of only the tested parameters that were accepted as improved fits for the model. In either case, the final row of the returned data frame are the best-fit parameters for that run.

The default number of iterations to find the best fit ("m") is 50 for rapid testing purposes, but 500 is more appropriate to ensure the model converges.  Two hyper-parameters ("lambda" and "testexp") can also adjust the rate of convergence.  The width (standard deviation) of the Gaussian curves used to sample new best-fit parameters is proportional to lambda.  A larger "lambda" will reduce the influence of the initial parameters by searching a larger parameter space, but may also waste many iterations by attempting numbers that have little chance of improving the fit.  The "testexp" hyper-parameter changes the penalty for having large variations from the experimental data.  The larger "testexp" is the more stringent the best-fit criteria are, but should always be an even integer (2 or 4 are recommended).

After the `final_drug_params` has been run `run_mod1` is run again on the final set of parameters to generate concentration vs. time data to be plotted.  An example of plotting the resulting data exists in model_2drugs.R using `ggplot2`. The example plotting function given plots the experimental data in black, initial results of `run_mod1` in green, and the final best-fit results in red.

`Iteration` is a wrapper function that takes a list of file indices and some normalization inputs and generates n sets of final best-fit parameters for each file at each frequency using the defined model.   The default value of n used in most runs was 100. After each frequency it appends its results to a single CSV file per index. Right now these files have to be reimported manually to calculate their statistics. This function just runs through everything; it does all the work.  It ran overnight on my small corner of Creighton's server space.

`facetgraph` is another wrapper function that produces a nine-panel graph of a single run of `final_drug_params` for each frequency using `ggplot2`. The resulting plot displays the experimental data in black, initial parameter results in green, and the final best-fit results in red. Alternatively if "consensus" is set to TRUE, it will instead assume the "init_params" are the final consensus values and not run `final_drug_params`. This is good for producing result graphs or for visual analysis of a model's fit at all frequencies.

#### descriptiveStatistics.R

descriptiveStatistics.R contains `findStatistics` that finds the min, max, mean, median, and standard deviation of best-fit parameters for each frequency for results from `Iteration` or a similar function. The file also contains `modelWD` a function to concatenate the model working directory. (*currently none of this has been tested*)

#### consesusPlot.R

consensusPlot.R generates consensus results and formats it to be plotted using `ggplot2`. While most of the functionality has been supplanted by `facetgraph`, it is sometimes useful to make a single plot for each frequency. It also plots all experimental data in the background, instead of just a single trace as in `facetgraph`.  Another function, `testConsensusFit`, takes the consensus results and tests their fits by calculating the percent error and the AUC of both the raw data and consensus values. (*Maybe delete this file and combine with descriptive statistics?; alternatively turn this into a consensus value analysis workflow*)
